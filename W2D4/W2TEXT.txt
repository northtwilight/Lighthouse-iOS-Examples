Mostly useless, but can be especially helpful when reading someone else’s code since it gives you a quick synopsis of what you’re looking at. 



You can help any programmer who may be using your code in the future by providing helpful comments using the AppleDoc comment syntax. These will show up in the Quick Help inspector and also when someone option-clicks on a class name in Xcode. 


You use the Objects Library to select different views or view controllers to dump into your Xib file or Storyboard. 

You can use the search feature to filter down the objects shown. Note that you can drop *any* object in your IB document, even non-view objects. 

All the tabs in this pane (different “libraries”) can be used either in Xcode or in IB. Be sure to check out the other ones too. 



The Document Outline

There are two important things to note here:

You get a hierarchical display of the view hierarchy you’ve built in IB. You could drag things around here for more precise control over which view is a subview of which view. 
You get references to Placeholders. These are objects that will already exist by the time your Nib loads. You can make connections to them and those connections will get establish at load time.








1. OO review and questions
2. Properties on objects
3. App Lifecycle: Advanced object inheritance and object composition 

   **@interface AppDelegate : UIResponder <UIApplicationDelegate>** :

   Combining the UIApplicationDelegate protocol with the UIResponder
   We talked about the different delegate methods in the app lifecycle: https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html

4. Views in brief
5. Events and the responder chain
6. A brief introduction to view controllers, (since we'll be working within the bounds of one)



Topics:

1. Application Lifecycle: Advanced object inheritance and object composition
   **@interface AppDelegate : UIResponder <UIApplicationDelegate>** :

   Combining the UIApplicationDelegate protocol with the UIResponder
   We talked about the different delegate methods in the app lifecycle: https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html

2. Apple MVC
3. Simple MVC program design
4. Their first visual app

5. `@IBOutlet`: public property to allow data connection between different views 
   `@IBActions` : Method definitions to handle IBOutlet output 
   EX: UIButton and target-action: 

   We ran out of time before discussing this but I explained it briefly after class, and for an excellent background reference please consult the following:
   
   https://nshipster.com/ibaction-iboutlet-iboutletcollection/

   This reference covers what they are, how they are defined (void return type methods etc), and what they do.
   It also considers when and why you would want to use IBOutlets and IBActions instead of using generic void returns.
   It describes why public property access is preferable to 'private' ivar access.
   Why IBOutlets are configured as weak.

   NB: **We will also cover this in much more depth tomorrow.**



No more terminal / command-line apps! From here on out, it's iOS time.

MVC stands for Model-View-Controller. iOS apps use MVC heavily.

• Models: Are the data objects.

• Views: Stuff we see. Minions of the controller.

• Controllers: Controls the communication between the view and the model. View controllers are controllers that are tightly coupled to the views.

Views
We can add view's to our screen by dragging them onto the view controller in the storyboard. We link the views to our code using an IBOutlet which is just a property that we can drag a blue line from. Some views, like buttons, can perform actions that we can link to our code.

We will be talking about `@IBOutlets`, as public properties on views and view controllers, and `@IBActions`, which handle methods attuned to those `@IBOutlets`, in-depth tomorrow. For now


Resources
Slides from today's lecture: https://docs.google.com/presentation/d/1GC9W-ZAa-aLLN-K5Rl9zWtKxBaPMTqE8RfMrq9uIWxs/edit#slide=id.g38fc4f24b_046

Code from today's lecture: https://github.com/northtwilight/Lighthouse-iOS-Examples/W2D1 (Multiple projects, programmatic and storyboard) - all three branches (master, develop and working) should be up to date.


# W2D1 - Breakout

## Developer Attitude

Edward James Olmos on developing your skills and cultivating the right attitude: https://www.youtube.com/watch?v=OvFDhYI-nfs&t=1115s 

(Starts at 18.15, watch to approximately 24.50) 

I'm not enough like this guy, but I definitely aspire to emulate him. Hope this helps.



## MVC Review

I have borrowed from David Mills' breakout materials as additional material.

Please find all of the demo files, and notes on github [here](https://github.com/philosopherdog/MVC-Breakout--Lighthouse-Labs).

Notice there are 2 branches. The demo code is in the `finished` branch so make sure you do a checkout `finished` to see the demo files.

Clone the project, cd into the repo, and use: `git checkout finished`.



## @IBActions and @IBOutlets

Paul Hegarty's MVC Lecture (ignore the Swift label at top, not relevant here) :

https://www.youtube.com/embed/-auG-myu02Q  (00:40 ~ 14:00)



## Further viewing

Paul Hegarty's Objective-C version of the iOS Course at Stanford University. 

This entire playlist is only available on YouTube now as it seems that older iOS versions have been deprecated significantly.

https://www.youtube.com/playlist?list=PL9qPUrlLU4jSlonxFqhWKBu2c_sWY-mzg

More recent versions of this course are available on iTunes U or the Podcasts app on Mac.





# Views, AutoLayout, Constraints and Animations

## Table of Contents

View geometry (frame vs bounds)
ObjC blocks
Animation (requires use of ObjC blocks)
Handling touches via responder methods
Autolayout constraints
UILabel and attributed strings
UIFont and UIColor (this may be a good place to review on categories)

## Lecture Detail

Today we talked about views & autolayout.

Views have two important jobs: handling touch events & displaying things on the screen.

The displaying part comes from the `CALayer` that each UIView contains.

Views can have `subviews` and form a view hierarchy.

Views have a `frame`, which is a `CGRect` struct, with a `CGPoint` called `origin` and a `CGSize` called `size`. The frame positions a view relative to its superview.

Autolayout is the default way of position views by a system of constraints or layout rules. Instead of explicitly positioning a view by coordinates, it lets us **declaratively** say where a view should be relative to other views in the hierarchy. The new SwiftUI framework similarly uses a declarative structure to create UI elements.

## Further references and code for review

Apple Human Interface Guidelines - provides a generalised but useful guide to overall UI guidelines and 'rules' for interaction:

https://developer.apple.com/design/human-interface-guidelines/ios/views/action-sheets/

Slides from today's lecture: https://docs.google.com/presentation/d/1KEIQiAT882SsrSHaC-NuJtUnFmoogI2rvmQozmRBK-g/edit#slide=id.p

Code from previous instructors to mull over and review: 

James Cash: https://bitbucket.org/jamesnvc/lhl-ios-w2d2-2019-05-07/src

Sam Meech-Ward: https://github.com/sam-meech-ward-lighthouse-labs/W2D2_Moar-Auto-Layout_2018-02-20

Danny Mathews: https://github.com/dmathewwws/W2D2-Views-AutoLayout

Roland Tecson: https://github.com/rtecson/20180807-lhl-w2d2

Amir Jahan: https://github.com/AmirJahan/LHL---W02-D02.git













W2D3


## Interface Builder & Storyboard

Interface Builder is the built in tool in Xcode for visually creating your user interfaces via a drag-and-drop mechanism. You can use it to layout your scenes (maps to a view controller), the views and controls within your scenes, and the navigation between your scenes (usually via segues).

There are two types of Interface Builder files:

 - Storyboards
 - XIBs

### Pros & Cons

There are many advantages to using Storyboards:

 - Visual layout
 - Easy to use
 - Faster to build user interfaces

There is one major caveat to watch out for:

 - Merge conflicts

Although this is becoming less of an issue with each release of Xcode, it is still possible to encounter merge conflicts when two or more developers are making changes to the same Storyboard file. There are a few ways to mitigate this:

 - Ensure that only one developer is working on a scene at any one time
 - Break up your storyboard into multiple, smaller storyboards (i.e. group all your "Settings" related scenes into one storyboard, etc.)

### XIBs

XIB files are Interface Builder files that correspond to `UIView`s. The most common reason for using a XIB file is for creating a custom or re-usable view that may be used anywhere in your app.

The main things to remember when using XIB files are:

 - It's possible to create multiple top-level views in your XIB file. However, in most cases, you would only have one top level `UIView`. All other views would be embedded inside this top level "content view".
 - You should create a corresponding `UIView` subclass that contains the logic for your custom view.
 - Two `init` methods should be overridden to make this custom class useful:
   - `-initWithFrame:` and
   - `-initWithCoder:`

The former is executed when your custom view is instantiated from code, while the latter is called when your custom view is instantiated from the Storyboard. Both of these init methods may call a common init method to initialize your class.

- In order to properly create `IBOutlet`s and `IBAction`s between your XIB file and your custom `UIView` class, you must set the "File Owner" property in the XIB file to be name of your custom class.

You may see the name NIB in some places. In most cases, XIBs and NIBs are analogous to each other. The main distinction is that a NIB is a compiled XIB.

### Storyboards

Storyboards are a very powerful mechanism of visually managing your scenes (view controller instances) and their relationships to other view controllers. You are able to create segues, which are navigation actions going from one view controller scene to another.

You can embed your scenes inside other specialized container view controllers such as:

 - Navigation view controllers
 - Tab bar view controllers
 - Page view controllers
 - Split view controllers

These container view controller provide additional capabilities that your view controllers can make use of.

### Size Classes

Size classes are a mechanism of determining the environment your app's views are in without directly referencing the device type. Size classes are defined for both the horizontal and vertical perspectives. Each axis may take on either a "compact" value or a "regular".

For example, on iPhone portrait mode, the horizontal size class is "compact" and the vertical size class is "regular" (abbreviated "wC hR").

When the device orientation changes (or when an iPad goes in or out of split screen mode), the size class might change. If so, your view controller will be notified that the size class attributes have changed.

If your views and layout constraints are set up to take advantage of size class attributes, they would automatically change in response to size class changes.

You may see all the size class variations here: https://useyourloaf.com/blog/size-classes/

### View Controller Life Cycle

Each view controller in your app goes through a life-cycle, which corresponds to specific methods that you may override in order to take action on these state changes.

- `-initWithNibName:bundle:` or `-initWithCoder:` -- the view controller instance is created
- `-viewDidLoad:` -- the view controller's view has been loaded. Note that `UIView`s may not be initialised yet at this point. In particular, the `frame` and `bound` attributes may not be set to the correct values.
- `-viewWillAppear:` -- the system is about to display your view controller on screen. All your views should be set up now and their actual positions and sizes should be correct.
- `-viewDidAppear` -- the system has displayed your view controller on screen
- `-viewWillDisappear` -- the system is about to take your view controller off screen. This may be because the user has navigated to another screen. It could also be because iOS is about to switch to another app (i.e. the user has pressed the "Home" button or has answered an incoming phone call).
- `-viewDidDisappear` -- the system has completed taking your view controller off screen
- `-didReceiveMemoryWarning` -- the system is low on memory. If you have any data structures that can be re-created (i.e. some cached info that may be retrieved again later), you can free them up here.

You may find more details on the view controller life cycle here: https://www.codementor.io/hemantkumar434/view-controller-lifecycle-ios-applications-7oyju9lp6

### Resources

 - Slides: https://docs.google.com/presentation/d/1FEqoNC86PVTQszLQyq6qhZNNUYHdWI3BkO4d_3wlnPQ/edit#slide=id.p
 - Code to explore: 

   - https://github.com/daegren/lhl-ios-w2d3-viewcontrollers-interfacebuilder
   - https://github.com/rtecson/lhl-20190116-intefacebuilder.git 
   - https://github.com/jyliang/LightHouseLabs/tree/master/2019-01-16
   - https://github.com/philosopherdog/W2D3-DemoFiles

 - Further reading:
   - View Controller Programming Guide: https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/index.html
   - https://www.codementor.io/hemantkumar434/view-controller-lifecycle-ios-applications-7oyju9lp6
   - Matt Neuburg, Programming iOS 7 (last Objective-C edition), pp 223-358, Interface - View Controller chapter
  



  W2D4
## Object Communication

## Delegates (as Protocol-nominated responsible objects)

These are great for one object to communicate with another object without knowing about that object (via the "messaging contract" as per protocols)

However, sometimes we want to be able to communicate with or notify multiple objects.

## Notifications - Using NSNotificationCenter with Notifications / UNUserNotifications

The shared instance of NotificationCenter allows us to broadcast information for any other objects to receive.

For example, a mountain could broadcast snow conditions to any object that wants to receive information about conditions. We could have an object monitoring a ski run, for instance.

Using `NSNotificationCenter`, we can send messages to parts of our app that are not otherwise connected. (Do not to be confuse `NSNotificationCenter` with the Notification Center feature of iOS which is used for receiving push notifications, i.e. catching up on your tweets).

To use send or receive notifications in your app, you need to grab a reference to the `NSNotification` singleton using `[NSNotificationCenter defaultCenter]`. This call will will instantiate the notification centre (if it hasn’t already been instantiated) or return the existing notification centre (if it has already been instantiated). No matter how many times you create references to it, there will only ever be one notification centre for your entire app. This is itself a communication pattern called the "singleton pattern", which allows many objects to easily find one instance of a class, based only on knowledge of that class. You may eventually learn to create your own singletons and access them from anywhere in your app. It’s not a super recommended way of doing things most of the time, though, and should only be used for certain design patterns.

Once your object has a reference to your notification centre, you can start listening for notifications using `addObserver:selector:name:object`. The observer (object—usually self) fires the specified selector (method) when it receives notifications with the specified notification name (an `NSString`). If we want to specify that we want notifications from only a specific object, we can add that object as a parameter. If the `object` parameter is nil, we will receive the named notification from any object.

To send a notification from an object we use the notification centre’s `postNotificaionName:object:` method. Again, we usually just use the named notification name (an `NSString`) to differentiate notifications. We can also include the sender in object if we want the receiving objects to be able to screen by sender.

 ### Notifications' example:

```NSNotification *notification = [NSNotification notificationWithName:@"notification-name" object:self];
[[NSNotificationCenter defaultCenter] postNotification:timerUpdatedNotification];
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(notificationHappend:) name:@"notification-name" object:nil];```


## Key-Value Observing (KVO)

Key point: Observe another object's properties and receive notifications when the property changes.

Extending our mountain example, a mountain could have a snow level property that other objects could observe without the mountain knowing.

We can also use the notification centre to detect when properties on other objects change their value. This is called Key-Value Observing (KVO). To do this, we need to add an observer by calling `addObserver:forKeyPath:options:context:` on the object we want to observe. The observer (observing object) will get a notification when the property identified by the keyPath is changed. We can ask the system to include additional information in that notification, like the new or old value of the property being changed by specifying options such as `NSKeyValueObservingOptionNew` or `NSKeyValueObservingOptionOld`. Note: if we wanted to observe both, the syntax would be `options: (NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld)`.

The observing object then needs to implement `observeValueForKeyPath:ofObject:change:context`. Because any KVO notification the object receives will fire this method, objects that observe multiple key values will have to screen for the right one be using a series of if/else statements to make sure they are firing the right activity for the right notifications. Any options you opted to use when sending the notification will be present in the changes dictionary, with their corresponding keys.

### KVO Example

```
[someObject addObserver:self forKeyPath:@"seconds" options:0 context:nil];
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSKeyValueChangeKey,id> *)change context:(void *)context
Gesture:
```

### IMPORTANT

*Important*: you should always remove observers from `NSNotificationCenter` before you deallocate them (remove them from memory). Because the notification centre is never deallocated, anything it has a reference to might also never get deallocated, and could cause a memory leak. It is standard practice to call `removeObserver:` on self in your observers' `dealloc` methods (or their `deinit()` methods in Swift). If you do not do this when using KVO, your app will crash.

## Target-Action and UIControl subclasses

We also looked at target-action communication, which you have already seen: it connects `@selectors` or methods with certain control events that are associated with the various subclasses of `UIControl`. You can set this up by control-dragging from the storyboard and choosing to create an "Action", or by calling `addTarget:action:forControlEvents` on an object you have a reference to in code. The target (usually self) will perform the action (method) whenever the control event takes place.

The method we specify should take one argument (often named "sender") of a type corresponding to the UIControl subclass that triggered it (for example `switchWasFlipped:(UISwitch *)sender`. When a control is triggered, it will pass itself to the method so we can analyze that control in the method to figure out what changed (for example, if the switch was turned on, we might have different behavior from when it is turned off). By default, this argument’s type is often set up with the type id. Make sure that the type is set correctly.

## Gesture Recognizers

Another place we use target-action is with gesture recognizers. When a gesture recognizer detects its specified action, it communicates this using the target-action pattern, passing a reference to itself as an argument. In our action method, we can analyze the gesture recognizer to figure out what the user is doing. All gesture recognizers have a state property we can use to figure out whether it was just triggered, is continuing to trigger, has just finished triggering, etc. All of them also have a `locationOfTouch:InView:` that we can use to figure out where the user is touching. Different kinds of gesture recognizers have other methods and properties. For example, `UIRotationGestureRecognizer` has a rotation property that returns its current rotation in radians.

### Sample gesture recognizer invocation

velocityInView
translationInView
setTranslation

sender.view.transform = CGAffineTransformMakeScale(sender.scale, sender.scale);

* We haven't covered CGAffineTransform explicitly in this course, but be aware that you can animate custom-drawn elements on-screen from outside of UIKit by utilising some Core Graphics structs and methods.


## NSTimer as an example

`[NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) {  }`





velocityInView
translationInView
setTranslation
sender.view.transform = CGAffineTransformMakeScale(sender.scale, sender.scale);
https://developer.apple.com/documentation/uikit/uipangesturerecognizer/1621207-translationinview










## Thanks

My thanks to Sam Meech-Ward, David Mills, Danny Mathews, Jason Liang and Roland Tecson for their project files and resources.

## Resources

Slides:

https://docs.google.com/presentation/d/15K6Y04nG1UgDAqqMRdG7n7cgyggjfGo7nS7SjwwLgPw/edit#slide=id.p

Code:

https://github.com/daegren/lhl-ios-apr29-w2d4-communications

Browser references:

* https://ios.compass.lighthouselabs.ca/days/w02d4/activities/936
* https://www.google.com/search?newwindow=1&ei=FblAXJuGL4WV0gKkl66wAQ&q=nshipster+kvo+nsnoticationcenter&oq=nshipster+kvo+nsnoticationcenter&gs_l=psy-ab.3..33i160.10775.18823..18920...3.0..0.171.1674.25j1......0....1..gws-wiz.......0i71j0j0i22i30j33i21.sIzFzvU3BtQ
* https://nshipster.com/nsnotification-and-nsnotificationcenter/
* https://nshipster.com/
* http://fuckingblocksyntax.com/
* http://fuckingclosuresyntax.com/
* https://www.google.com/search?q=nstimer&oq=nstimer&aqs=chrome..69i57j0l5.2357j0j7&sourceid=chrome&ie=UTF-8
* https://developer.apple.com/documentation/foundation/nstimer
* https://www.google.com/search?newwindow=1&biw=1280&bih=553&tbm=isch&sa=1&ei=hctAXKScE-WU0wLV6q3IBQ&q=pickle+rick+png&oq=pickle+rick+png&gs_l=img.3..0j0i30j0i5i30.42419.42761..42863...0.0..0.48.178.4......1....1..gws-wiz-img.......0i67.AB7JaGDaM90#imgrc=nioyJ3GSQaOdPM:
* https://www.google.com/search?newwindow=1&ei=eM1AXOvoHISm8AOoyaPYBQ&q=UITapGestureRecognizer+storyboard+action&oq=UITapGestureRecognizer+storyboard+action&gs_l=psy-ab.3..33i160.104471.105181..105310...0.0..0.103.457.6j1......0....1..gws-wiz.......0i71j0i22i30j33i21.GxcxPKSFCGE
* https://guides.codepath.com/ios/Using-Gesture-Recognizers
* https://www.raywenderlich.com/433-uigesturerecognizer-tutorial-getting-started







## Some example code

* https://github.com/sam-meech-ward-lighthouse-labs/Phoneagochi
* https://bitbucket.org/jamesnvc/lhl-w2d4-breakout-2018-08-09/src/master/
* https://github.com/dmathewwws/iOS-Breakout-W2D4/tree/master/Phonagotchi
